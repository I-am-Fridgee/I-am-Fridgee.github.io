<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Fridgee's animator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- React and ReactDOM CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <style>
        /* --- General & Layout --- */
        .bloxd-container { font-family: sans-serif; background-color: #f0f0f0; color: #333; margin: 0; padding: 20px; }
        .bloxd-inner-container { max-width: 1000px; margin: auto; background-color: #fff; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .bloxd-container h1, .bloxd-container h2 { border-bottom: 2px solid #eee; padding-bottom: 10px; }

        /* --- Drop Zone --- */
        #drop-zone { border: 3px dashed #ccc; padding: 40px; text-align: center; color: #888; margin-bottom: 20px; transition: background-color 0.2s; }
        #drop-zone.drag-over { background-color: #e0eafc; border-color: #3b82f6; }
        #error-message { color: #dc2626; font-weight: bold; margin-top: 10px; min-height: 1.2em; }

        /* --- Frames --- */
        #frames-container { min-height: 100px; padding: 10px; background-color: #f9f9f9; border: 1px solid #ddd; }
        .frame-card { background-color: #fff; border: 1px solid #ccc; padding: 15px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; cursor: grab; user-select: none; }
        .frame-card:active { cursor: grabbing; }
        .frame-card.dragging { opacity: 0.5; }
        .frame-card .file-name { font-family: monospace; font-size: 0.9em; color: #555; margin: 0 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; }
        .frame-card .frame-label { font-weight: bold; }
        .frame-card button { margin-left: 5px; }

        /* --- Playback & Controls --- */
        .controls, .export-section { margin-top: 20px; }
        .controls label { margin-left: 15px; user-select: none; }
        .frame-card.playing { border-left: 5px solid #3b82f6; box-shadow: 0 0 8px rgba(59, 130, 246, 0.5); }
        #export-output { width: 100%; min-height: 200px; margin-top: 10px; font-family: monospace; font-size: 0.85em; padding: 10px; box-sizing: border-box; background-color: #1e1e1e; color: #d4d4d4; border: 1px solid #333; }

        /* --- Footer --- */
        .footer-info {
            margin-top: 40px;
            padding: 16px 0 0 0;
            border-top: 2px solid #eee;
            color: #444;
            font-size: 1em;
            text-align: center;
            background: none;
        }
        .footer-info .footer-label {
            font-weight: bold;
            margin-right: 8px;
        }
        .footer-info .footer-email {
            color: #2563eb;
            text-decoration: underline;
            margin-right: 16px;
        }
        .footer-info .footer-nick {
            color: #059669;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/javascript">
        const { useState, useEffect, useRef } = React;

        function BloxdAnimator() {
            const [frames, setFrames] = useState([]);
            const [errorMessage, setErrorMessage] = useState('');
            const [isDragOver, setIsDragOver] = useState(false);
            const [draggedItemId, setDraggedItemId] = useState(null);
            const [playingFrameId, setPlayingFrameId] = useState(null);

            const nextId = useRef(0);
            const playbackIntervalRef = useRef(null);
            const currentFrameIndexRef = useRef(0);

            const handleFileDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragOver(false);
                setErrorMessage('');
                const files = Array.from(e.dataTransfer.files);
                let hasInvalidFile = false;
                let filesToProcess = [];
                files.forEach(file => {
                    if (file.name.endsWith('.bloxdschem')) {
                        filesToProcess.push(file);
                    } else {
                        hasInvalidFile = true;
                    }
                });
                if (hasInvalidFile) {
                    setErrorMessage('Error: Only .bloxdschem files are supported. Invalid files were ignored.');
                }
                filesToProcess.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const newFrame = {
                            id: nextId.current++,
                            fileName: file.name,
                            fileContent: event.target.result
                        };
                        setFrames(prevFrames => [...prevFrames, newFrame]);
                    };
                    reader.readAsText(file);
                });
            };

            const deleteFrame = (idToDelete) => {
                setFrames(prevFrames => prevFrames.filter(f => f.id !== idToDelete));
            };

            const copyFrame = (idToCopy, index) => {
                const frameToCopy = frames.find(f => f.id === idToCopy);
                if (frameToCopy) {
                    const newFrame = { ...frameToCopy, id: nextId.current++ };
                    const newFrames = [...frames];
                    newFrames.splice(index + 1, 0, newFrame);
                    setFrames(newFrames);
                }
            };

            const handleFrameDragStart = (e, id) => {
                setDraggedItemId(id);
                e.dataTransfer.effectAllowed = 'move';
                e.currentTarget.classList.add('dragging');
            };

            const handleFrameDragOver = (e) => {
                e.preventDefault();
            };

            const handleFrameDrop = (e, dropTargetId) => {
                e.preventDefault();
                const draggedItemIndex = frames.findIndex(f => f.id === draggedItemId);
                const dropTargetIndex = frames.findIndex(f => f.id === dropTargetId);
                if (draggedItemIndex !== -1 && dropTargetIndex !== -1 && draggedItemIndex !== dropTargetIndex) {
                    const newFrames = [...frames];
                    const [removed] = newFrames.splice(draggedItemIndex, 1);
                    newFrames.splice(dropTargetIndex, 0, removed);
                    setFrames(newFrames);
                }
            };

            const handleDragEnd = () => {
                document.querySelector('.dragging')?.classList.remove('dragging');
                setDraggedItemId(null);
            };

            const handlePlayback = () => {
                if (playbackIntervalRef.current) {
                    clearInterval(playbackIntervalRef.current);
                    playbackIntervalRef.current = null;
                    setPlayingFrameId(null);
                    return;
                }
                if (frames.length === 0) return;
                currentFrameIndexRef.current = 0;
                playbackIntervalRef.current = setInterval(() => {
                    const isLooping = document.getElementById('loop-toggle')?.checked;
                    if (currentFrameIndexRef.current >= frames.length) {
                        if (isLooping) {
                            currentFrameIndexRef.current = 0;
                        } else {
                            clearInterval(playbackIntervalRef.current);
                            playbackIntervalRef.current = null;
                            setTimeout(() => setPlayingFrameId(null), 500);
                            return;
                        }
                    }
                    const currentFrameData = frames[currentFrameIndexRef.current];
                    if (currentFrameData) {
                        setPlayingFrameId(currentFrameData.id);
                    }
                    currentFrameIndexRef.current++;
                }, 500);
            };

            useEffect(() => {
                return () => {
                    if (playbackIntervalRef.current) {
                        clearInterval(playbackIntervalRef.current);
                    }
                };
            }, []);

            const generateExportCode = () => {
                const outputEl = document.getElementById('export-output');
                if (!outputEl) return;
                if (frames.length === 0) {
                    outputEl.value = "-- Add some frames first to export code.";
                    return;
                }
                const framesData = frames.map(frame => {
                    const escapedContent = frame.fileContent.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
                    return `"${escapedContent}"`;
                }).join(',\n    ');
                const code = `-- Generated by Bloxd.io Animation Manager
-- This code animates schematics based on your frames.

-- Configuration
local ANIMATION_SPEED = 10 -- Ticks per frame (20 ticks = 1 second)
local PLAY_ON_START = true -- Set to false if you want to trigger it manually

-- Frame Data (Do not edit)
local frames = {
        ${framesData}
}
local totalFrames = ${frames.length}
local currentFrame = 1
local tickCounter = 0

-- Function to load a schematic frame
function loadFrame(frameNumber)
        if frames[frameNumber] then
                -- NOTE: Bloxd.io does not have a native 'loadSchematicFromString' function.
                -- The user must manually save each frame as a schematic in-game
                -- and then call setBlocksFromSchematic() with the correct name.
                -- This code assumes schematics are named "frame1", "frame2", etc.
                setBlocksFromSchematic("frame"..frameNumber, getPos())
                print("Loaded frame " .. frameNumber)
        end
end

-- onTick is called every game tick (20 times per second)
onTick(function()
        if not PLAY_ON_START then return end
        
        tickCounter = tickCounter + 1
        if tickCounter >= ANIMATION_SPEED then
                tickCounter = 0 -- Reset counter
                
                currentFrame = currentFrame + 1
                if currentFrame > totalFrames then
                        currentFrame = 1 -- Loop animation
                end
                
                loadFrame(currentFrame)
        end
end)

-- onStart is called when the code block is loaded
onStart(function()
        print("Animation script started. Total frames: " .. totalFrames)
        if PLAY_ON_START then
                loadFrame(currentFrame)
        end
end)

-- You will need to save each of your .bloxdschem files in-game
-- with the names "frame1", "frame2", "frame3", etc. for this to work.
`;
                outputEl.value = code;
            };

            return (
                React.createElement(React.Fragment, null,
                    React.createElement("div", { className: "bloxd-container" },
                        React.createElement("div", { className: "bloxd-inner-container" },
                            React.createElement("h1", null, "Bloxd.io Animation Manager"),
                            React.createElement("h2", null, "Step 1: Add Frames"),
                            React.createElement("div", {
                                id: "drop-zone",
                                className: isDragOver ? 'drag-over' : '',
                                onDragEnter: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOver(true); },
                                onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOver(false); },
                                onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); },
                                onDrop: handleFileDrop
                            }, "Drag & Drop .bloxdschem files here"),
                            React.createElement("div", { id: "error-message" }, errorMessage),
                            React.createElement("h2", null, "Step 2: Manage Frames"),
                            React.createElement("div", { id: "frames-container" },
                                frames.map((frame, index) =>
                                    React.createElement("div", {
                                        key: frame.id,
                                        className: `frame-card${playingFrameId === frame.id ? ' playing' : ''}`,
                                        draggable: true,
                                        onDragStart: (e) => handleFrameDragStart(e, frame.id),
                                        onDragOver: handleFrameDragOver,
                                        onDrop: (e) => handleFrameDrop(e, frame.id),
                                        onDragEnd: handleDragEnd
                                    },
                                        React.createElement("div", null,
                                            React.createElement("span", { className: "frame-label" }, `Frame ${index + 1}`)
                                        ),
                                        React.createElement("span", { className: "file-name" }, frame.fileName),
                                        React.createElement("div", null,
                                            React.createElement("button", { className: "copy-button", onClick: () => copyFrame(frame.id, index) }, "Copy"),
                                            React.createElement("button", { className: "delete-button", onClick: () => deleteFrame(frame.id) }, "Delete")
                                        )
                                    )
                                )
                            ),
                            React.createElement("h2", null, "Step 3: Playback & Export"),
                            React.createElement("div", { className: "controls" },
                                React.createElement("button", { id: "play-button", onClick: handlePlayback },
                                    playbackIntervalRef.current ? 'Stop' : 'Play'
                                ),
                                React.createElement("label", null,
                                    React.createElement("input", { type: "checkbox", id: "loop-toggle" }), " Loop"
                                )
                            ),
                            React.createElement("div", { className: "export-section" },
                                React.createElement("button", { id: "export-button", onClick: generateExportCode }, "Export Bloxd Code"),
                                React.createElement("textarea", { id: "export-output", readOnly: true, placeholder: "Generated Bloxd.io code will appear here..." })
                            )
                        ),
                        // Footer with your info
                        React.createElement("div", { className: "footer-info" },
                            React.createElement("span", { className: "footer-label" }, "G-mail:"),
                            React.createElement("a", { className: "footer-email", href: "mailto:I-am-Fridgee@gmail.com" }, "I-am_Fridgee@gmail.com"),
                            React.createElement("span", { className: "footer-label" }, "Bloxd Nickname:"),
                            React.createElement("span", { className: "footer-nick" }, "I_am_Fridgee")
                        )
                    )
                )
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(BloxdAnimator));
    </script>
</body>
</html>
